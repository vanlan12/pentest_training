      ##CẤU TRÚC DỮ LIỆU

###**Tìm hiểu về tuples,sets,dict**

**1.TUPLE**
-Tuple là một dãy các đối tượng không thể bị thay đổi trong Python. Các tuple cũng là các dãy giống các List.
-Tuple sử dụng các dấu ngoặc đơn.Các đối tượng trong tuple được phân biệt bởi dấu phẩy và được bao quanh bởi dấu ngoặc đơn ().
Ví dụ:

```sh
data=(10,20,'ram',56.8)
```
tuple trống không chứa phần tử nào,ví dụ:

`tup1 =();`

Với một tuple chỉ có một giá trị đơn,thì phải có dấu phẩy ở cuối,ví dụ:

`tup1 =(50,);`

Các tuple cũng có thể được lồng vào nhau, ví dụ:

```sh
tup11='a','hoang',10.56
        tup12=tup11,(10,20,30)
        print tup11
        print tup12
```
Kết quả:

```sh
('a',`hoang`,10.56)
(('a','hoang',10.56), (10,20,30))
```

####**Truy cập giá trị tuple**
-Tương tự list ta có thể truy cập các phần tử tuple:

```sh
tup1 = ('vatly','hoahoc',1997);
tup2 = (1,2,3,4);
print "tup1[0]: ", tup1[0]
print "tup2[1:3]", tup2[1:5]
```
Kết quả:

```sh
tup1[0]: vatly
tup2[1:3]: [2,3]
```
####**Các hoạt động cơ bản tuple tương tự trên list và string**
####**Xóa các phần tử của tuple trong Python**
Xóa là không thể.Chỉ có thể xóa toàn bộ tuple với lệnh `del`:
####**Cập nhật phần tử trong tuple**
Các phần tử không thể được cập nhật.Tuy nhiên các tuple có thể được sử dụng để tạo nên một tuple mới.
####**Một số hàm trong tuple**

-cmp(tuple1,tuple2): So sánh 2 tuple

-len(tuple): Trả về độ dài của tuple

-max(tuple):Trả về item có giá trị lớn nhất từ một tuple đã cho

-min(tuple):Trả vè item có giá trị nhỏ nhất từ một tuple đã cho

-tuple(seq):Chuyển đỗi một dãy thành tuple

**2.Sets**
-Sets là một list các giá trị không có các mục nào trùng lặp lẫn nhau.

<li>Khi bạn muốn thu thập các từ riêng biệt trong một đoạn văn:</li>

`print set ("my name is Eric and Eric is my name".split())

--->`set(['and', 'is', 'my', 'name', 'Eric'])`

-Sets còn là một công cụ hỗ trợ đắc lực trong Python.Sets giúp ta tìm ra các từ khác nhau hay các từ trùng nhau.

<li>Ví dụ với 2 event A,B:</li>
 
```sh
a=set(["Jake","John","Eric"])
b=set(["John","Jill"])
```
 -Để tìm ra các từ có ở trong 2 event ta có thể dùng hàm"**intersection**"

```sh
>>>a.intersection(b)
set(['John'])
>>>b.intersection(a)
set(['John'])
```
-Để tìm ra các từ chỉ tồn tại ở một event, ta có thể dùng hàm "**symmetric_difference**"

```sh
>>> a.symmetric_difference(b)
set(['Jill', 'Jake', 'Eric'])
>>> b.symmetric_difference(a)
set(['Jill', 'Jake', 'Eric'])
```
-Để tìm ra các từ chỉ tồn tại ở một event và chỉ ở riêng mục đó, dùng hàm "**difference**"

```sh
>>> a.difference(b)
set(['Jake', 'Eric'])
>>> b.difference(a)
set(['Jill'])
```
-Để nhận được danh sách của tất cả các từ, ta dùng hàm "**union**"

```sh
>>> a.union(b)
set(['Jill', 'Jake', 'John', 'Eric'])
```

**3.dict**
Dictionary trong python là một tập hợp các cặp key và value không có thứ tự.Nó là một tập hợp chứa dữ liệu, được bao quanh bởi các dấu ngoặc móc đơn {}.Value có thể là bất kỳ kiểu giá trị nào.Key là một kiểu dữ liệu không thay đổi như chuỗi,số hoặc tuple.

Ví dụ:

```sh
data={100:'Hoang' ,101:'Nam' ,102:'Binh'}
print data
```
Kết quả là :

```sh
{100: 'Hoang', 101: 'Nam',102: 'Binh'}
```

###**Các thuộc tính của key**
-Không có hạn chế về value, tuy nhiên với Key cần chú ý

+Không cho phép bản sao key xuất hiện.Khi bắt gặp bản sao key trong phép gán, thì phép gán cuối cùng được thực hiện.Ví dụ:

```sh
dict = {'Ten': 'Hoang', 'Tuoi': 7, 'Ten': 'Nam'};
print "dict['Ten']: ",dict ['Ten]"
```
Kết quả

`dict['Ten']: Nam`

+Key phải là ko đổi.Nghĩa là bạn chỉ có thể sử dụng chuỗi, số hoặc tuple làm key của Dictionary.Ví dụ:

```sh
dict = {['Ten']: 'Hoang', 'Tuoi': 7};
print "dict['Ten']: ", dict['Ten']
```
Kết quả

```sh
Traceback (most recent call last):
  File "test.py", line 3, in <module>
    dict = {['Ten']: 'Hoang', 'Tuoi': 7};
TypeError: list objects are unhashable
```

###**Dịch bài tại urllib2.urlopen()**
Các chuyên mục của hàm **urllib2** có các chức năng sau:

`urllib2.urlopen(url[,data[,timeout[,cafile[,capath[,cadefault[,context]]]]]])`

Mở một URL(được sử dụng để tham chiếu tới tài nguyên trên mạng internet).Nó có thể là một chuỗi hoặc một đối tượng **Request**.

**data** có thể là một chuỗi xác định dữ liệu bổ sung để gửi tới máy chủ, hoặc `None`(trống) nếu  những dữ liệu đó là không cần thiết.Các truy vấn HTTP hiên tại là truy vấn duy nhất sử dụng dữ liệu ; Yêu cầu HTTP sẽ là POST thay vi là GET khi tham số da ta được cung cấp.Data nên được xem là bộ đệm trong định dạng chuẩn application/x-ww-form-unrlencoded.Hàm **urllib.urlencode()** nhận một mapping hoặc trình tự 2 chuỗi tuples và trả về chuỗi định dạng của nó.Module urlib2 gửi một truy vấn HTTP/1.1 cùng tiêu đề `Connection:close` :

Các tùy chọn tham số timeout được quy định một thời gian chờ trong giây để ngăn chặn các hoạt động như nỗ lực kết nối(Nếu không được quy định,thiết lập thời gian chờ toàn cầu mặc định sẽ được sử dụng).Các điều này chỉ được sử dụng đối với các kết nối HTTP,HTTPS và FTP.

Nếu phạm vi được chỉ định, nó phải là một trường hợp **ssl.SSlContext** mô tả các tùy chọn SSL. Xem các Kết nối HTTPS để biết thêm các thông tin.

Các tùy chọn cafile và tham số capath chỉ định một tệp tin chửng chỉ CA cho yêu cầu của HTTPS.cafile phải trỏ đến một tệp tin duy nhất có chứa một gói giấy chứng nhận CA,trong khi **capath** phải trỏ đến một thư mục chứa các file chứng nhận hashed (!?).Một số thông tin có thể được tìm thấy ở **ssl.SSLContext.load_verify_locations()**.

Các tham số cadefault đã được bỏ qua

Hàm này trả về một đối tượng tệp tin giống như ba phương pháp dưới đây:
   
   <li> geturl()-Quay trở lại URL của các nguồn truy cập,thường được sử dụng để xác định xem một chuyển hướng đã được theo sau hay chưa</li>

   <li> info() - quay về thông tin gốc của trang,chẳng hạn như tiêu đề, trong một dạng của trường hợp**minetools.Message**.(Tham khảo ở [Quick Reference to HTTP Headers](www.cs.tut.fi/~jkorpela/http.html))</li>

   <li> getcode() - trả lại trạng thái của HTTP của phần phản hồi</li>

Thêm URLerror vào mục lỗi

Lưu ý None có thể trả lại nếu không thể giải quyết được yêu cầu(Măc dù mặc định toàn cầu OpenerDirecor sử dụng UnknownHandler để đảm bảo điều này không bao giờ xảy ra) 

Ngoài ra, nếu thiết lập proxy bị  phát hiện(Ví dụ, khi một biến môi trường như http_proxy được thiết lập),ProxyHander là một cài đặt mặc định và đảm bảo các yêu cầu được xử lý thông qua proxy.

###**Dịch urllib2.Request**
urllib2.Request(url[, data][, headers][, origin_req_host][, unverifiable])
   
   <li>lớp này là một phần của một yêu cầu URL</li>

   <li>url phải là một chuỗi chứa URL hợp lệ</li>

   <li>data có thể là một chuỗi các quy định cụ thể các dữ liệu bổ sung để gửi tới máy chủ,hoặc là không cần nếu như dữ liệu đó không cần thiết.Các yêu cầu HTTP hiện này chỉ đơn thuần về sử dụng các gói data.Các dữ liệu HTTP  sẽ là một Post Post thay vì một Get khi các thông số dự liệu được cung cấp.Data nên là một bộ đệm chuẩn trong application/x-www-form-unlencoded định dạng chuẩn.Hàm **urllib.urlencode() lấy một mapping hoặc trình tự của 2-tuples và trả về một chuỗi trong định dạng này</li>

   <li>Header nên là một thư mục và sẽ được coi như là đối số nếu add_header() đã được gọi với mỗi phím và giá trị như các đối số </li>

   <li>**add_header()** được dùng với từng khóa (key) và giá trị (value). Điều này thường được sử dụng để `nhái lại` giá trị tựa đề **User-Agent**, được sử dụng bởi trình duyệt để xác định chính nó - một số máy chủ HTTP chỉ cho phép yêu cầu đến từ các trình duyệt phổ biến và điều này trái ngược với scripts. Ví dụ, Mozilla Firefox có thể xác định chính nó như *"Mozilla/5.0 (X11; U; Linux i686) Gecko/20071127 Firefox/2.0.0.11"*, trong khi chuỗi user-agent mặc định của urllib2 là *"Python-urllib/2.6"*</li>
   
   <li>Các đối số cuối cùng chỉ quan tâm các thao tác chính của bên thứ 3 HTTP cookie:</li>
   
   <li>origin_req_host là các yêu cầu chủ của các thao tác gốc, được định nghĩa bởi RFC 2965.Nó mặc định để cookielib.request_host(self). Đây là tên máy chủ hoặc địa chỉ IP của yêu cầu ban đầu đã được khởi xưởng bởi người dùng. Ví du, nếu các yêu cầu cho một hình ảnh trong một tài liệu HTML, đó là request_host cho yêu cầu đối với trang chứa hình ảnh đó</li>
   
   <li>unverifiable nên chỉ xem là yêu cầu chưa được kiểm chứng, được định nghĩa bởi RFC 2965. Nó mặc định là False.Một yêu cầu chưa được kiểm chứng là có URL mà người dùng không có quyền để phê duyệt. Ví dụ, nếu yêu cầu là một bản sao trong một tài liệu HTML, và người sử dụng không có tùy chọn để tự động duyệt các bản sao, điều này phải là đúng</li>









