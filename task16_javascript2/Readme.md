# JAVASCRIPT CƠ BẢN>Người thực hiện: Lưu Văn Lân>Nguồn tài liệu: [javascript cơ bản](http://javascript.info/)>Ngày đăng: 17/4/2017# MỤC LỤC[2.11 Logical operators](#2.11)[2.12 Loops: while and for](#2.12)[ 2.13 The "switch" statement](#2.13)[2.14 Functions](#2.14)[2.15 Function expressions and arows](#2.15)## 2.11 Logical operators<a name="2.11"></a>>Có 3 toán tử Logic tồn tại trong JavaScript : `||` (OR) , `&&` (AND) , `!` (NOT)### II (OR)>result = a || b;- Trong các chương trình cổ điển, toán tử OR dùng để thao tác với các giá trị Boolean. Nếu có bất kỳ đối số nào trong nó là `True` thì kết quả trả về sẽ là `True`, nếu không thì trả về `False`. Có 4 kết quả hợp lý như sau:```shalert( true || true );   // truealert( false || true );  // truealert( true || false );  // truealert( false || false ); // false```- Nếu các toán hạng không phải là Boolean thì nó sẽ được chuyển sang dạng boolean để đánh gía.#### Ví dụ:```shif (1 || 0) { // Ở đây hoạt động giống như là ( true || false) và kết quả trả về true  alert( 'truthy!' );}```- Hầu như là toán tử OR thường được dùng trong `if` để kiểm tra.### OR seeks the first truthy value- Chức năng login của OR ở trên là hơi cổ điển. Bây giờ đi sâu vào các tính năng của nó:- Thuật toán mở rộng có dạng:>result = value1 || value2 || value3;- Toán tử OR `||` hoạt động theo cơ chế như sau:	+ Xét từng toán hạng từ trái sang phải.	+ Với mỗi giá trị chuyển sang dạng boolean. Nếu nó là `trues` thì dừng lại và trả về giá trị đó.	+ Nếu xét hết các toán hạng thì trả về giá trị cuối cùng.	+ Giá trị trả về là giá trị không bị biến đổi.#### Ví dụ:```shalert( 1 || 0 ); // 1 (1 là giá trị đúng	)alert( true || 'no matter what' ); // (true is la giá trị đúng)alert( null || 1 ); // 1 (1 là giá trị đúng)alert( null || 0 || 1 ); // 1 (Giá trị đầu tiên đúng)alert( undefined || null || 0 ); // 0 (tất cả đều sai, trả về giá trị cuối cùng là 0)```**1. Lấy ra giá trị đúng đầu tiên trong một danh sách các biến và các biểu thức mà trong đó vừa có giá trị hoặc là `null/undefined`**```shlet currentUser = null;let defaultUser = "John";let name = currentUser || defaultUser || "unnamed";alert( name ); // Kết quả trả về là John, vì John là giá trị đúng đầu tiên```Nếu như cả hai `curentUser` và `DefaultUsser` Đều là False thì kết quả cuối cùng sẽ là `unnamed`.**2.Short-circuit evaluation**- Các toán hạng không chỉ là các giá trị, mà nó còn có thể là các biểu thức. OR sẽ đánh giá từ trái sang phải. Nó sẽ trả về giá trị nếu giá trị đó là đúng.- Dễ thấy nhất ta xét với trường hợp gán biến:```shlet x;true || (x = 1);alert(x); // undefined, Bởi vì (x =1) không được đánh giá```Và nếu như đối số đầu là false , thì nó sẽ đánh giá biểu thức tiếp theo:```shlet x;false || (x = 1);alert(x); // 1```### && (AND)>result = a && b;- Ở các chương trình cổ điển, toán tử `AND` sẽ trả về giá trị `trues` nếu tất cả toán hạng đều đúng và `false` với trường hợp còn lại:```shalert( true && true );   // truealert( false && true );  // falsealert( true && false );  // falsealert( false && false ); // false```### AND seeks the first falsy value-Thuật toán mở rộng của AND như sau:>result = value1 && value2 && value3; - AND `&&` hoạt động theo cơ chế như sau:	+ Đánh giá các toán hạng từ trái sang phải.	+ Với mỗi giá trị chuyển sang dạng boolean. Nếu kết quả là `false` , dừng lại và trả về giá trị ban đầu.		+ Nếu kết thúc các giá trị, giá trị nào cũng `trues` thì trả về giá trị cuối cùng.	+ Tức là nó sẽ trả về giá trị sai đầu tiên hoặc là giá trị cuối cùng nếu không tìm thấy giá trị sai.#### Ví dụ:```shalert( 1 && 0 ); // 0alert( 1 && 5 ); // 5alert( null && 5 ); // nullalert( 0 && "no matter what" ); // 0```		### ! (NOT)- Cú pháp rất đơn giản.>result = !value;-Toán tử chấp nhận một đối số duy nhất và thực hiện như sau:	+ Chuyển toán hạng thành dạng boolean : `true/false`	+ Trả về giá trị ngịch đảo#### Ví dụ:```shalert( !true ); // falsealert( !0 ); // true```- A double NOT `!!` đôi khi được dùng để chuyển giá trị sang giá trị boolean:#### Ví dụ:```shalert( !!"non-empty string" ); // truealert( !!null ); // false```## 2.12 Loops: while and for<a name="2.12"></a>### The “while” loop- Vòng lặp `While` có cú pháp như sau:```while dowhile (Điều kiện) {  // code  // còn được gọi là "loop body"}```- Khi **điều kiện** là đúng thì đoạn code trong phần **loop body** sẽ được thực thi.### The "do...while" loop- Vòng lặp `do....while` có cú pháp như sau:```do whiledo {  // loop body} while (Điều kiện);```-Vòng lặp đầu tiên sẽ được thực thi trong phần **loop body**, sau đó nó sẽ kiểm tra phần **Điều kiện**. Nếu điều kiện đó là đúng thì nó sẽ thực thi tiếp vòng lặp và cứ thế lặp đi lặp lại.### The “for” loop- Vòng lặp `For` có cú pháp như sau```Forfor (Bắt đầu; Điều kiện; step) {  // ... loop body ...}```#### Skipping parts-Bất cứ phần nào trong vòng lặp `for` đều có thể được bỏ qua.	+Ví dụ : Chúng ta có thể bỏ qua phần bắt đầu```shlet i = 0; // Chúng ta đã khai báo biến ifor (; i < 3; i++) { //Không cần phần bắt đầu  alert( i ); // 0, 1, 2}```		+Ví dụ: Chúng ta cũng có thể không cần luôn phần step```shlet i = 0;for (; i < 3;) {  alert( i );}```---> Vòng lặp trở nên giống nhau và lặp lại liên tục	+Ví dụ: Chúng ta có thể bỏ hết tất cả để tạo ra một vòng lặp vô hạn```shfor (;;) {  // repeats without limits}```### Breaking the loop- Chúng ta dùng chức năng đặc biệt `break` để phá vỡ vòng lặp và dừng hẳn vòng lặp### Continue to the next iteration- Chức năng đặc biệt `continue` nó hơi khác `break` ở chỗ nó cũng dừng vòng lặp nhưng không dừng hẳn vòng lặp mà bắt buộc vòng lặp thực hiện một vòng lặp mới nếu điều kiện cho phép.- Ví dụ vòng lặp dưới đây chỉ xuất ra các số lẻ:```shfor (let i = 0; i < 10; i++) {  // Nếu đúng bỏ qua phần còn lại của vòng lặp  if (i % 2 == 0) continue;  alert(i); // 1, then 3, 5, 7, 9}```#### NOTE:- `Break/continue` Không được sử dụng trong biểu thức có `?`;`(i > 5) ? alert(i) : continue; // continue không được thực thi`### Labels for break/continue- Đôi khi chúng ta cần thoát ra nhiều vòng lặp lồng nhau cùng một lúc- Đoạn code dưới đây chúng ta sẽ lặp lại `i` và `j` và yêu cầu toạn độ `(i,j)` từ `(0,0)` tới `(3,3)`:```shfor (let i = 0; i < 3; i++) {  for (let j = 0; j < 3; j++) {    let input = prompt(`Value at coords (${i},${j})`, '');    // what if I want to exit from here to Done (below)?  }}alert('Done!');```- Chúng ta cần một cách để hủy bỏ quá trình xử lí Nếu người dùng hủy bỏ đầu vào.- Việc phá vỡ bằng `break` chỉ có thể phá hủy các lớp trong như thế là không đủ. Giải pháp ở đây là `Labels`- `Labels` là một định danh đặt trước vòng lặp:>labelName: for(...) {>  ...>}- Câu lệnh `break <LabelName>` trong vòng lặp sẽ dừng vòng lặp lại ngay tại nơi nhãn được định danh.```shouter: for (let i = 0; i < 3; i++) {  for (let j = 0; j < 3; j++) {    let input = prompt(`Value at coords (${i},${j})`, '');    // Nếu đầu vào là một chuỗi trống hay không có gì thì nó sẽ thoát ra khỏi cả hai vòng lặp    if (!input) break outer; // (*)  }}alert('Done!');```- Ta cũng có thể di chuyển nhãn vào một chuỗi riêng biệt:```shouter:for (let i = 0; i < 3; i++) { ... }```- Chức năng continue cũng có thể được sử dụng với nhãn. Trong trường hợp này việc thực thi sẽ được nhảy tới lần lặp tiếp theo của vòng lặp đã được gán nhãn.#### Note:- Nhãn không cho phép nhảy vào một nơi mã tùy ý. Ví dụ:```shbreak label;  // jumps to label? No.label: for(...)```- Chức năng `break/continue` chỉ có thể được thực thi bên trong vòng lặp, và nhãn phải được đặt ở trên cả phần chức năng.## 2.13 The "switch" statement<a name="2.13"></a>- Một chức năng `Switch` có thể thay thế nhiều lệnh kiểm tra `if`- Nó đưa ra một cách mô tả rõ ràng hơn để so sánh một giá trị với nhiều biến thể### The Syntax- `Switch` có một hoặc nhiều khối `case` và một mặc định tùy chọn```shswitch(x) {  case 'value1':  // if (x === 'value1')    ...    [break]  case 'value2':  // if (x === 'value2')    ...    [break]  default:    ...    [break]}```	+ Giá trị của `x` được kiểm tra một cách bình đẳng với từng giá trị trong từng `case`.	+ Nếu thỏa mãn được giá trị trong case đó - `switch` sẽ bắt đầu thực thi khối lệnh tồn tại trong `case` , và thực hiện lệnh `break` gần nhất. (hoặc là kết thúc `switch`)	+ Nếu không có trường hợp nào khớp thì đoạn code `default` sẽ được thực thi (Nếu có tồn tại)### An example- Một ví dụ cho `switch`:```shlet a = 2 + 2;switch (a) {  case 3:    alert( 'Too small' );    break;  case 4:    alert( 'Exactly!' );    break;  case 5:    alert( 'Too large' );    break;  default:    alert( "I don't know such values" );}```---> Đoạn code thực thi nằm trong case 4.#### Note:- Bất kỳ đối số nào cũng có thể là một đối số `switch/case`- Cả hai `switch` và `case` đều cho phép biểu thức tùy ý.### Grouping of “case”- Mỗi biến thể trong `case` chia sẻ cùng một đoạn code đều có thể được nhóm lại.- Ví dụ ta muốn cùng một đoạn code chạy trong hai case `case3` và `case5````shlet a = 2 + 2;switch (a) {  case 4:    alert('Right!');    break;  case 3:                    // (*) grouped two cases  case 5:    alert('Wrong!');    alert('How about to take maths classes?');    break;  default:    alert('The result is strange. Really.');}```---> Bây giờ cả hai `case 3` và `case 5` đều show ra cùng một tin nhắn.### Type matters- Chúng ta phải nhấn mạnh rằng tất cả các giá trị phải có cùng kiểu để so sánh- Ví dụ: Hãy xem xét mã:```shlet arg = prompt("Enter a value?")switch (arg) {  case '0':  case '1':    alert( 'One or zero' );  case '2':    alert( 'Two' );    break;  case 3:    alert( 'Never executes!' );  default:    alert( 'An unknown value' )}```	+ 1. Với case '1','0', thì dòng alert đầu tiên sẽ xuất hiện	+ 2. Với case '2', thì dòng alert xuất hiện	+ 3. Nhưng với case 3, Kết quả của `prompt` là một chuỗi `"3"` , và nó không cùng kiểu dạng với `3` . Và chúng ta nhận được một đoạn mã chết ở case 3## 2.14 Functions<a name="2.14"></a>###  Function Declaration![text](http://i.imgur.com/9loYJYE.png)- Cú pháp khai báo của một hàm:>fuction Tên_của_hàm(Các thông số)  {>	Phần thân của hàm. Viết code ở đây> }### Local variables- Một biến khi khai báo bên trong hàm thì chỉ được hiển thị bên trong hàm đó```shfunction showMessage() {  let message = "Hello, I'm JavaScript!"; // Biến bên trong  alert( message );}showMessage(); // Hello, I'm JavaScript!alert( message ); // <-- Lỗi  vì biến này được khai báo bên trong hàm```### Outer variables- Một hàm có thể truy cập vào một biến được khai báo bên ngoài```shlet userName = 'John';function showMessage() {  let message = 'Hello, ' + userName;  alert(message);}showMessage(); // Hello, my name is John```- Một biến ngoài chỉ được dùng khi không tồn tại biến trong.### Default values- Nếu một thông số không được cung cấp, thì nó sẽ được cung cấp giá trị là `undefined`- Nếu ta muốn dùng một đoạn `text` bình thường thì ta có thể dùng `==`. Ta có thể gán cho `text` có thể là `string` hay một `fuction` hay một biểu thức nào đó```shfunction showMessage(from, text = "no text given") {  alert( from + ": " + text );}showMessage("Ann"); // Ann: no text given```## 2.15 Function expressions and arrows<a name="2.15"></a>- Một hàm nếu được khai báo mà không cần điều kiện thì được gọi là `Function Declaration````shfunction sayHi() {  alert( "Hello" );}```- Một hàm nếu được khai báo bên trong một biểu thức thì được goi là `Function Expresion````shlet sayHi = function() {  alert( "Hello" );};```### Arrow functions- Arrow functions là cách khai báo hàm đơn giản:>let func = (arg1, arg2, ...argN) => expression```sh// expression at the right sidelet sum = (a, b) => a + b;// or multiline syntax with { ... }, need return here:let sum = (a, b) => {  // ...  return a + b;}// without argumentslet sayHi = () => alert("Hello");// with a single argumentlet double = n => n * 2;```	+ Hàm này có nhiều biến local , tức là biến được khai báo bên trong hàm	+ Các thông số có thể có nhiều giá trị mặc định: `function sum(a=1, b=2) {...}`	+ Chức năng này luôn luôn trả về một giá trị nào đó. Nếu không có giá trị nào trả về , thì kết quả là `undefined`